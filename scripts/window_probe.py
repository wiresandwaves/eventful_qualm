"""
# mypy: ignore-errors
window_probe.py
Find windows, print client rectangle (DPI-aware), and emit a ROI TOML template.
Usage:
  python window_probe.py [--title "Window"] [--out eq_<WxH>.toml]
Notes:
  - Uses only ctypes (no external deps).
  - Captures CLIENT RECT (excludes title/borders) for consistent ROI anchoring.
"""

import argparse
import ctypes
import sys
from ctypes import wintypes


# --- DPI awareness (Per Monitor V2 if available) ---
def _make_dpi_aware():
    try:
        shcore = ctypes.windll.shcore
        # 2 = PROCESS_PER_MONITOR_DPI_AWARE
        shcore.SetProcessDpiAwareness(2)
    except Exception:
        try:
            user32 = ctypes.windll.user32
            user32.SetProcessDPIAware()
        except Exception:
            pass


# --- Win32 helpers ---
user32 = ctypes.windll.user32
kernel32 = ctypes.windll.kernel32

EnumWindows = user32.EnumWindows
EnumWindowsProc = ctypes.WINFUNCTYPE(ctypes.c_bool, wintypes.HWND, wintypes.LPARAM)
IsWindowVisible = user32.IsWindowVisible
GetWindowTextW = user32.GetWindowTextW
GetWindowTextLengthW = user32.GetWindowTextLengthW
GetClientRect = user32.GetClientRect
ClientToScreen = user32.ClientToScreen


class POINT(ctypes.Structure):
    _fields_ = [("x", ctypes.c_long), ("y", ctypes.c_long)]


class RECT(ctypes.Structure):
    _fields_ = [
        ("left", ctypes.c_long),
        ("top", ctypes.c_long),
        ("right", ctypes.c_long),
        ("bottom", ctypes.c_long),
    ]


def _get_window_text(hwnd):
    length = GetWindowTextLengthW(hwnd)
    buf = ctypes.create_unicode_buffer(length + 1)
    GetWindowTextW(hwnd, buf, length + 1)
    return buf.value


def _client_rect(hwnd):
    rect = RECT()
    if not GetClientRect(hwnd, ctypes.byref(rect)):
        return None
    # top-left in client coords -> screen coords
    pt = POINT(0, 0)
    if not ClientToScreen(hwnd, ctypes.byref(pt)):
        return None
    # Convert to screen-space rectangle
    left, top = pt.x, pt.y
    right = left + rect.right
    bottom = top + rect.bottom
    width = rect.right
    height = rect.bottom
    return (left, top, right, bottom, width, height)


def _find_windows_by_title(substr):
    matches = []

    def _cb(hwnd, lparam):
        if not IsWindowVisible(hwnd):
            return True
        title = _get_window_text(hwnd)
        if substr.lower() in title.lower():
            matches.append((hwnd, title))
        return True

    EnumWindows(EnumWindowsProc(_cb), 0)
    return matches


TOML_TEMPLATE = """# Auto-generated by eq_window_probe.py
# Coordinate space: CLIENT (excludes titlebar/borders)
# Units: px for absolute, or *_pct for normalized [0..1] if you prefer resolution-agnostic ROIs.
[meta]
name = "Window"
width = {w}
height = {h}
coordinate_space = "client"
units = "px"

[rois]
# Full client area (for baseline capture)
full = {{ x = 0, y = 0, w = {w}, h = {h} }}

# Example normalized regions (adjust to your UI layout).
# You can switch to x_pct/y_pct/w_pct/h_pct to make them resolution-agnostic.
chat = {{ x_pct = 0.02, y_pct = 0.74, w_pct = 0.42, h_pct = 0.24 }}
target_name = {{ x_pct = 0.38, y_pct = 0.03, w_pct = 0.24, h_pct = 0.05 }}
player_hp = {{ x_pct = 0.02, y_pct = 0.10, w_pct = 0.18, h_pct = 0.08 }}
target_hp = {{ x_pct = 0.38, y_pct = 0.08, w_pct = 0.24, h_pct = 0.03 }}
"""


def main():
    _make_dpi_aware()

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--title", default="Window", help="Substring to match window titles (default: Window)"
    )
    parser.add_argument("--out", default=None, help="If provided, write TOML template to this path")
    args = parser.parse_args()

    wins = _find_windows_by_title(args.title)
    if not wins:
        print(f"No visible windows matching '{args.title}' found.", file=sys.stderr)
        sys.exit(1)

    print(f"Found {len(wins)} window(s):")
    best = None
    for i, (hwnd, title) in enumerate(wins, 1):
        rect = _client_rect(hwnd)
        if rect is None:
            continue
        left, top, right, bottom, w, h = rect
        print(f"[{i}] hwnd=0x{hwnd:08X}  title='{title}'  client=({w}x{h}) at ({left},{top})")
        # pick the largest client area by default
        if best is None or (w * h) > (best[-1] * best[-2]):
            best = (hwnd, title, left, top, right, bottom, w, h)

    if best is None:
        print("Couldn't get client rects.", file=sys.stderr)
        sys.exit(2)

    _, title, _, _, _, _, w, h = best
    print("\nSuggested ROI profile filename:")
    fn = f"eq_{w}x{h}.toml"
    print(f"  {fn}")

    toml = TOML_TEMPLATE.format(w=w, h=h)
    print("\n--- TOML TEMPLATE BEGIN ---")
    print(toml.rstrip())
    print("--- TOML TEMPLATE END ---")

    if args.out:
        try:
            with open(args.out, "w", encoding="utf-8") as f:
                f.write(toml)
            print(f"\nWrote: {args.out}")
        except Exception as e:
            print(f"Failed to write file: {e}", file=sys.stderr)
            sys.exit(3)


if __name__ == "__main__":
    main()
